/*-------------------------------------------------------------------------
 *
 * combocid.c
 *	  Combo command ID support routines
 *
 * Before version 8.3, HeapTupleHeaderData had separate fields for cmin
 * and cmax.  To reduce the header size, cmin and cmax are now overlayed
 * in the same field in the header.  That usually works because you rarely
 * insert and delete a tuple in the same transaction, and we don't need
 * either field to remain valid after the originating transaction exits.
 * To make it work when the inserting transaction does delete the tuple,
 * we create a "combo" command ID and store that in the tuple header
 * instead of cmin and cmax. The combo command ID can be mapped to the
 * real cmin and cmax using a backend-private array, which is managed by
 * this module.
 *
 * To allow reusing existing combo cids, we also keep a hash table that
 * maps cmin,cmax pairs to combo cids.  This keeps the data structure size
 * reasonable in most cases, since the number of unique pairs used by any
 * one transaction is likely to be small.
 *
 * With a 32-bit combo command id we can represent 2^32 distinct cmin,cmax
 * combinations. In the most perverse case where each command deletes a tuple
 * generated by every previous command, the number of combo command ids
 * required for N commands is N*(N+1)/2.  That means that in the worst case,
 * that's enough for 92682 commands.  In practice, you'll run out of memory
 * and/or disk space way before you reach that limit.
 *
 * The array and hash table are kept in TopTransactionContext, and are
 * destroyed at the end of each transaction.
 *
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/time/combocid.c
 *
 *-------------------------------------------------------------------------
 */

#include "postgres.h"

#include "access/htup_details.h"
#include "access/parallel.h"
#include "access/session.h"
#include "access/xact.h"
#include "miscadmin.h"
#include "storage/shmem.h"
#include "utils/combocid.h"
#include "utils/hsearch.h"
#include "utils/memutils.h"

/* Hash table to lookup combo cids by cmin and cmax */
static HTAB *comboHash = NULL;

/* Key and entry structures for the hash table */
typedef struct
{
	CommandId	cmin;
	CommandId	cmax;
} ComboCidKeyData;

typedef ComboCidKeyData *ComboCidKey;

/*
 * Shared memory version of the array for use in parallel queries.  For now we
 * don't have a shared memory hash table, we just let each backend deduplicate
 * as much as it can, but all participating backends can decode each other's
 * combo CIDs through this structure.  It is protected by shared_combocid_lock.
 */
typedef struct SharedComboCidRegistry
{
	size_t		size;
	size_t		used;
	ComboCidKeyData	combocids[FLEXIBLE_ARRAY_MEMBER];
} SharedComboCidRegistry;

typedef struct
{
	ComboCidKeyData key;
	CommandId	combocid;
} ComboCidEntryData;

typedef ComboCidEntryData *ComboCidEntry;


/* Initial size of the hash table */
#define CCID_HASH_SIZE			100


/*
 * An array of cmin,cmax pairs, indexed by combo command id.
 * To convert a combo cid to cmin and cmax, you do a simple array lookup.
 */
static ComboCidKey comboCids = NULL;
static int	usedComboCids = 0;	/* number of elements in comboCids */
static int	sizeComboCids = 0;	/* allocated size of array */

/*
 * For the shared memory version of the above, used for parallel queries, see
 * session.h.
 */

/* Initial size of the array */
#define CCID_ARRAY_SIZE			100


/* prototypes for internal functions */
static CommandId GetComboCommandId(CommandId cmin, CommandId cmax);
static CommandId GetSharedComboCommandId(CommandId cmin, CommandId cmax);
static CommandId GetLocalComboCommandId(CommandId cmin, CommandId cmax);
static CommandId GetRealCmin(CommandId combocid);
static CommandId GetRealCmax(CommandId combocid);


/**** External API ****/

/*
 * GetCmin and GetCmax assert that they are only called in situations where
 * they make sense, that is, can deliver a useful answer.  If you have
 * reason to examine a tuple's t_cid field from a transaction other than
 * the originating one, use HeapTupleHeaderGetRawCommandId() directly.
 */

CommandId
HeapTupleHeaderGetCmin(HeapTupleHeader tup)
{
	CommandId	cid = HeapTupleHeaderGetRawCommandId(tup);

	Assert(!(tup->t_infomask & HEAP_MOVED));
	Assert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));

	if (tup->t_infomask & HEAP_COMBOCID)
		return GetRealCmin(cid);
	else
		return cid;
}

CommandId
HeapTupleHeaderGetCmax(HeapTupleHeader tup)
{
	CommandId	cid = HeapTupleHeaderGetRawCommandId(tup);

	Assert(!(tup->t_infomask & HEAP_MOVED));

	/*
	 * Because GetUpdateXid() performs memory allocations if xmax is a
	 * multixact we can't Assert() if we're inside a critical section. This
	 * weakens the check, but not using GetCmax() inside one would complicate
	 * things too much.
	 */
	Assert(CritSectionCount > 0 ||
		   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));

	if (tup->t_infomask & HEAP_COMBOCID)
		return GetRealCmax(cid);
	else
		return cid;
}

/*
 * Given a tuple we are about to delete, determine the correct value to store
 * into its t_cid field.
 *
 * If we don't need a combo CID, *cmax is unchanged and *iscombo is set to
 * false.  If we do need one, *cmax is replaced by a combo CID and *iscombo
 * is set to true.
 *
 * The reason this is separate from the actual HeapTupleHeaderSetCmax()
 * operation is that this could fail due to out-of-memory conditions.  Hence
 * we need to do this before entering the critical section that actually
 * changes the tuple in shared buffers.
 */
void
HeapTupleHeaderAdjustCmax(HeapTupleHeader tup,
						  CommandId *cmax,
						  bool *iscombo)
{
	/*
	 * If we're marking a tuple deleted that was inserted by (any
	 * subtransaction of) our transaction, we need to use a combo command id.
	 * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper
	 * than a TransactionIdIsCurrentTransactionId call.
	 */
	if (!HeapTupleHeaderXminCommitted(tup) &&
		TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tup)))
	{
		CommandId	cmin = HeapTupleHeaderGetCmin(tup);

		*cmax = GetComboCommandId(cmin, *cmax);
		*iscombo = true;
	}
	else
	{
		*iscombo = false;
	}
}

/*
 * Combo command ids are only interesting to the inserting and deleting
 * transaction, so we can forget about them at the end of transaction.
 */
void
AtEOXact_ComboCid(void)
{
	/*
	 * Don't bother to pfree. These are allocated in TopTransactionContext, so
	 * they're going to go away at the end of transaction anyway.
	 */
	comboHash = NULL;

	comboCids = NULL;
	usedComboCids = 0;
	sizeComboCids = 0;

	/*
	 * If we're attached a shared registry, the leader marks it empty, but
	 * we'll keep the memory around for use by future transactions.
	 */
	if (!IsParallelWorker() && CurrentSession &&
		CurrentSession->shared_combocid_registry)
		CurrentSession->shared_combocid_registry->used = 0;
}


/**** Internal routines ****/

/*
 * Get a combo command id that maps to cmin and cmax.
 *
 * We try to reuse old combo command ids when possible, but for now we only
 * consider combos created by this backend.  Another process in the same
 * parallel query could generate a distinct different combo command IDs for the
 * same transaction, but all processes will be able to understand that combo
 * command ID.
 */
static CommandId
GetComboCommandId(CommandId cmin, CommandId cmax)
{
	/*
	 * Create the hash table and array the first time we need to use combo
	 * cids in the transaction.
	 */
	if (comboHash == NULL)
	{
		HASHCTL		hash_ctl;

		/* Make array first; existence of hash table asserts array exists */
		comboCids = (ComboCidKeyData *)
			MemoryContextAlloc(TopTransactionContext,
							   sizeof(ComboCidKeyData) * CCID_ARRAY_SIZE);
		sizeComboCids = CCID_ARRAY_SIZE;
		usedComboCids = 0;

		memset(&hash_ctl, 0, sizeof(hash_ctl));
		hash_ctl.keysize = sizeof(ComboCidKeyData);
		hash_ctl.entrysize = sizeof(ComboCidEntryData);
		hash_ctl.hcxt = TopTransactionContext;

		comboHash = hash_create("Combo CIDs",
								CCID_HASH_SIZE,
								&hash_ctl,
								HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);
	}

	if (CurrentSession && CurrentSession->shared_combocid_registry)
		return GetSharedComboCommandId(cmin, cmax);
	else
		return GetLocalComboCommandId(cmin, cmax);
}

static CommandId
GetSharedComboCommandId(CommandId cmin, CommandId cmax)
{
	CommandId	combocid;
	ComboCidKeyData key;
	ComboCidEntry entry;
	bool		found;

	/* Check if we already have it before taking any locks. */
	key.cmin = cmin;
	key.cmax = cmax;
	entry = (ComboCidEntry) hash_search(comboHash,
										&key,
										HASH_ENTER,
										&found);
	if (found)
		return entry->combocid;

	/* We'll create a new one in shared memory. */
	LWLockAcquire(&CurrentSession->fixed->shared_combocid_lock, LW_EXCLUSIVE);

	/* If the shared memory array is already full, we'll have to expand it. */
	if (CurrentSession->shared_combocid_registry->used ==
		CurrentSession->shared_combocid_registry->size)
	{
		SharedComboCidRegistry *old_data;
		SharedComboCidRegistry *new_data;
		dsa_pointer	new_data_dsa;
		size_t		new_size;

		/* Double the size of the array. */
		new_size = CurrentSession->shared_combocid_registry->size * 2;
		new_data_dsa = dsa_allocate_extended(CurrentSession->area,
											 offsetof(SharedComboCidRegistry,
													  combocids) +
											 sizeof(ComboCidKeyData) *
											 new_size,
											 DSA_ALLOC_NO_OOM);
		if (new_data_dsa == InvalidDsaPointer)
		{
			/* Undo the new hash table entry. */
			hash_search(comboHash, &key, HASH_REMOVE, &found);
			LWLockRelease(&CurrentSession->fixed->shared_combocid_lock);
			elog(ERROR, "out of memory");
		}

		/* Copy the old contents into the new array. */
		old_data = CurrentSession->shared_combocid_registry;
		new_data = (SharedComboCidRegistry *)
			dsa_get_address(CurrentSession->area, new_data_dsa);
		memcpy(new_data, old_data, offsetof(SharedComboCidRegistry,
											combocids) +
											sizeof(ComboCidKeyData) *
											old_data->used);
		new_data->size = new_size;

		/* Free the old array. */
		dsa_free(CurrentSession->area,
				 CurrentSession->fixed->shared_combocid_registry_dsa);

		/* Advertise the new array for other backends to notice. */
		CurrentSession->fixed->shared_combocid_registry_dsa = new_data_dsa;
		CurrentSession->fixed->shared_combocid_change++;

		/* Set our own local pointer so we can access it. */
		CurrentSession->shared_combocid_registry = new_data;
	}

	/* Now we can add a new entry. */
	combocid = CurrentSession->shared_combocid_registry->used++;
	CurrentSession->shared_combocid_registry->combocids[combocid].cmin = cmin;
	CurrentSession->shared_combocid_registry->combocids[combocid].cmax = cmax;
	entry->combocid = combocid;

	LWLockRelease(&CurrentSession->fixed->shared_combocid_lock);

	return combocid;
}

static CommandId
GetLocalComboCommandId(CommandId cmin, CommandId cmax)
{
	CommandId	combocid;
	ComboCidKeyData key;
	ComboCidEntry entry;
	bool		found;

	/*
	 * Grow the array if there's not at least one free slot.  We must do this
	 * before possibly entering a new hashtable entry, else failure to
	 * repalloc would leave a corrupt hashtable entry behind.
	 */
	if (usedComboCids >= sizeComboCids)
	{
		int			newsize = sizeComboCids * 2;

		comboCids = (ComboCidKeyData *)
			repalloc(comboCids, sizeof(ComboCidKeyData) * newsize);
		sizeComboCids = newsize;
	}

	/* Lookup or create a hash entry with the desired cmin/cmax */

	/* We assume there is no struct padding in ComboCidKeyData! */
	key.cmin = cmin;
	key.cmax = cmax;
	entry = (ComboCidEntry) hash_search(comboHash,
										(void *) &key,
										HASH_ENTER,
										&found);

	if (found)
	{
		/* Reuse an existing combo cid */
		return entry->combocid;
	}

	/* We have to create a new combo cid; we already made room in the array */
	combocid = usedComboCids;

	comboCids[combocid].cmin = cmin;
	comboCids[combocid].cmax = cmax;
	usedComboCids++;

	entry->combocid = combocid;

	return combocid;
}

/*
 * Another backend could have replaced the array in order to expand it.  Make
 * sure that CurrentSession->shared_combocid_registry points to the current
 * one.
 */
static inline void
ensure_shared_combocid_registry(void)
{
	if (unlikely(CurrentSession->fixed->shared_combocid_change !=
				 CurrentSession->shared_combocid_change))
	{
		CurrentSession->shared_combocid_registry = (SharedComboCidRegistry *)
			dsa_get_address(CurrentSession->area,
							CurrentSession->fixed->shared_combocid_registry_dsa);
		CurrentSession->shared_combocid_change =
			CurrentSession->fixed->shared_combocid_change;
	}
}

static CommandId
GetRealCmin(CommandId combocid)
{
	if (CurrentSession && CurrentSession->shared_combocid_registry)
	{
		CommandId	result;

		LWLockAcquire(&CurrentSession->fixed->shared_combocid_lock, LW_SHARED);
		ensure_shared_combocid_registry();
		result = CurrentSession->shared_combocid_registry->combocids[combocid].cmin;
		LWLockRelease(&CurrentSession->fixed->shared_combocid_lock);

		return result;

	}
	else
	{
		Assert(combocid < usedComboCids);
		return comboCids[combocid].cmin;
	}
}

static CommandId
GetRealCmax(CommandId combocid)
{
	if (CurrentSession && CurrentSession->shared_combocid_registry)
	{
		CommandId	result;

		LWLockAcquire(&CurrentSession->fixed->shared_combocid_lock, LW_SHARED);
		ensure_shared_combocid_registry();
		result = CurrentSession->shared_combocid_registry->combocids[combocid].cmax;
		LWLockRelease(&CurrentSession->fixed->shared_combocid_lock);

		return result;
	}
	else
	{
		Assert(combocid < usedComboCids);
		return comboCids[combocid].cmax;
	}
}

void
SharedComboCidRegistryInit(dsm_segment *seg, dsa_area *area)
{
	SharedComboCidRegistry *new_data;
	dsa_pointer		new_data_dsa;

	/*
	 * No need to acquire the lock, because during initialization no workers
	 * are running yet.
	 */

	new_data_dsa = dsa_allocate(area,
								offsetof(SharedComboCidRegistry,
										 combocids) +
								sizeof(ComboCidKeyData) * sizeComboCids);
	new_data = (SharedComboCidRegistry *) dsa_get_address(area, new_data_dsa);

	/* Copy all existing combos into shared memory. */
	new_data->size = sizeComboCids;
	new_data->used = usedComboCids;
	memcpy(&new_data->combocids, comboCids,
		   sizeof(ComboCidKeyData) * usedComboCids);

	/* Advertise the new array for other backends to notice. */
	CurrentSession->fixed->shared_combocid_registry_dsa = new_data_dsa;
	CurrentSession->fixed->shared_combocid_change = 1;

	/* Set our own local pointer so we can access it. */
	CurrentSession->shared_combocid_registry = new_data;

	/* XXX install cleanup callback */
}

void
SharedComboCidRegistryAttach(void)
{
	LWLockAcquire(&CurrentSession->fixed->shared_combocid_lock, LW_SHARED);
	ensure_shared_combocid_registry();
	LWLockRelease(&CurrentSession->fixed->shared_combocid_lock);

	/* XXX install cleanup callback */
}
