#! /usr/bin/perl -w
#-------------------------------------------------------------------------
#
# Gen_nodeHashjoinSpecializations.pl
#    Perl script that generates nodeHashjoinSpecializations.c
#
# Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
# Portions Copyright (c) 1994, Regents of the University of California
#
#
# IDENTIFICATION
#    src/backend/executor/Gen_nodeHashjoinSpecializations.pl
#
#-------------------------------------------------------------------------

print <<OFH;
/*-------------------------------------------------------------------------
 *
 * nodeHashjoinSpecializations.c
 *    Machine-generated code included by nodeHashjoin.c.
 *
 *	******************************
 *	*** DO NOT EDIT THIS FILE! ***
 *	******************************
 *
 *	GENERATED by src/backend/executor/Gen_nodeHashjoinSpecializations.pl
 *
 *-------------------------------------------------------------------------
 */


typedef TupleTableSlot *(*ExecHashJoin_specialized_function)(PlanState *state);

OFH

@parallel = ("Serial", "Parallel");
@fill_inner = ("", "FillInner");
@fill_outer = ("", "FillOuter");
@booleans = qw(false true);

for my $i (0 .. $#parallel) {
  for my $j (0 .. $#fill_inner) {
    for my $k (0 .. $#fill_outer) {
	  # skip unsupported combinations
	  if ($i == 1 && $j == 1) {
	    # parallel with fill_inner not supported
        next;
      }
	  print "\n";
	  print "static TupleTableSlot *\n";
	  print "ExecHashJoin_$parallel[$i]$fill_inner[$j]$fill_outer[$k](PlanState *state)\n";
	  print "{\n";
	  print "\treturn ExecHashJoinImpl(state, $booleans[$i], $booleans[$j], $booleans[$k]);\n";
	  print "}\n";
	}
  }
}

print "\n";
print "\n";
print "const static ExecHashJoin_specialized_function ExecHashJoin_specialization_table[$#parallel + 1][$#fill_inner + 1][$#fill_outer + 1] =\n";
print "{\n";
foreach $parallel (@parallel) {
  print "\t{\n";
  foreach $fill_inner (@fill_inner) {
	print "\t\t{\n";
    foreach $fill_outer (@fill_outer) {
	  if ($parallel eq "Parallel" && $fill_inner eq "FillInner") {
	    print "\t\t\t\tNULL,\n";
	  } else {
	    print "\t\t\t\tExecHashJoin_$parallel$fill_inner$fill_outer,\n";
	  }
	}
	print "\t\t},\n";
  }
  print "\t},\n";
}
print "};\n";

print <<OFH;

static ExecHashJoin_specialized_function
GetExecHashJoinFunction(HashJoinState *node, bool parallel)
{
	return ExecHashJoin_specialization_table[parallel][HJ_FILL_INNER(node)][HJ_FILL_OUTER(node)];
}
OFH

