#!/bin/sh

# number of uint32s in the object (so 1 means a 4 byte object)
SIZES="1 2 3 4"

# different values to test for insertion sorts
THRESHOLDS="7 8 9 10 11 12 13"

# amount of data to sort, in megabytes
MEMORY=2048

echo "/* generated by make-object-tests.sh, included by test_sort_perf.c */"
echo

for size in $SIZES ; do

  # generate the object
  echo "typedef struct object_$size {"
  echo "    uint32 array[$size];"
  echo "} object_$size;"
  echo

  # generate the traditional qsort comparator for comparison
  echo "static int"
  echo "object_cmpvoid_$size(const void *a, const void *b)"
  echo "{"
  echo "    const object_$size *ax = (const object_$size *) a;"
  echo "    const object_$size *bx = (const object_$size *) b;"
  echo "    if (ax->array[0] < bx->array[0])"
  echo "        return -1;"
  echo "    else if (ax->array[0] > bx->array[0])"
  echo "        return 1;"
  echo "    else"
  echo "        return 0;"
  echo "}"
  echo

  # generate the int32 comparator
  echo "static pg_attribute_always_inline int32"
  echo "object_cmp_$size(const object_$size *a, const object_$size *b)"
  echo "{"
  echo "    if (a->array[0] < b->array[0])"
  echo "        return -1;"
  echo "    else if (a->array[0] > b->array[0])"
  echo "        return 1;"
  echo "    else"
  echo "        return 0;"
  echo "}"
  echo

  # generate the int64 comparator
  echo "static pg_attribute_always_inline int64"
  echo "object_cmp64_$size(const object_$size *a, const object_$size *b)"
  echo "{"
  echo "    return (int64) a->array[0] - (int64) - b->array[0];"
  echo "}"
  echo

  # make 32 bit and 64 bit sort functions for each insertion threshold
  for threshold in $THRESHOLDS ; do
    echo "#define ST_SORT sort_${threshold}_object_$size"
    echo "#define ST_ELEMENT_TYPE object_$size"
    echo "#define ST_COMPARE(a, b) object_cmp_$size(a, b)"
    echo "#define ST_SCOPE static"
    echo "#define ST_SORT_SMALL_THRESHOLD $threshold"
    echo "#define ST_CHECK_FOR_INTERRUPTS"
    echo "#define ST_DECLARE"
    echo "#define ST_DEFINE"
    echo "#include \"lib/sort_template.h\""
    echo
    echo "#define ST_SORT sort64_${threshold}_object_$size"
    echo "#define ST_ELEMENT_TYPE object_$size"
    echo "#define ST_COMPARE(a, b) object_cmp64_$size(a, b)"
    echo "#define ST_COMPARE_RET_TYPE int64"
    echo "#define ST_SCOPE static"
    echo "#define ST_SORT_SMALL_THRESHOLD $threshold"
    echo "#define ST_CHECK_FOR_INTERRUPTS"
    echo "#define ST_DECLARE"
    echo "#define ST_DEFINE"
    echo "#include \"lib/sort_template.h\""
    echo
  done

done

# generate the function that runs all the tests
echo "static void"
echo "do_sort_object(void)"
echo "{"
for size in $SIZES ; do
  echo "    {"
  echo "        size_t nobjects = (1024 * 1024 * (size_t) $MEMORY) / sizeof(object_$size);"
  echo "        object_$size *unsorted = malloc(sizeof(object_$size) * nobjects);"
  echo "        object_$size *sorted = malloc(sizeof(object_$size) * nobjects);"
  echo

  for order in random increasing decreasing ; do
    echo "        for (size_t i = 0; i < nobjects; ++i)"
    echo "        {"
    if [ "$order" = "random" ] ; then
      echo "            uint32 v = random();"
    elif [ "$order" = "increasing" ] ; then
      echo "            uint32 v = i;"
    elif [ "$order" = "decreasing" ] ; then
      echo "            uint32 v = UINT_MAX - i;"
    fi
    echo "            for (int j = 0; j < $size; ++j)"
    echo "                unsorted->array[j] = v;"
    echo "        }"
    echo

    for threshold in $THRESHOLDS ; do
      if [ "$threshold" = "7" ] ; then
        # compare against traditional qsort too, when using threshold 7
        echo "        for (int i = 0; i < 3; ++i)"
        echo "        {"
        echo "            instr_time start_time, end_time;"
        echo "            memcpy(sorted, unsorted, sizeof(sorted[0]) * nobjects);"
        echo "            INSTR_TIME_SET_CURRENT(start_time);"
        echo "            qsort(sorted, nobjects, sizeof(sorted[0]), object_cmpvoid_$size);"
        echo "            INSTR_TIME_SET_CURRENT(end_time);"
        echo "            INSTR_TIME_SUBTRACT(end_time, start_time);"
        echo "            elog(NOTICE, \"[traditional qsort] size=$size, order=$order, threshold=$threshold, cmp=32, test=%d, time=%f\", i, INSTR_TIME_GET_DOUBLE(end_time));"
        echo "        }"
      fi
      echo "        for (int i = 0; i < 3; ++i)"
      echo "        {"
      echo "            instr_time start_time, end_time;"
      echo "            memcpy(sorted, unsorted, sizeof(sorted[0]) * nobjects);"
      echo "            INSTR_TIME_SET_CURRENT(start_time);"
      echo "            sort_${threshold}_object_$size(sorted, nobjects);"
      echo "            INSTR_TIME_SET_CURRENT(end_time);"
      echo "            INSTR_TIME_SUBTRACT(end_time, start_time);"
      echo "            elog(NOTICE, \"size=$size, order=$order, threshold=$threshold, cmp=32, test=%d, time=%f\", i, INSTR_TIME_GET_DOUBLE(end_time));"
      echo "        }"
      echo "        for (int i = 0; i < 3; ++i)"
      echo "        {"
      echo "            instr_time start_time, end_time;"
      echo "            memcpy(sorted, unsorted, sizeof(sorted[0]) * nobjects);"
      echo "            INSTR_TIME_SET_CURRENT(start_time);"
      echo "            memcpy(sorted, unsorted, sizeof(sorted[0]) * nobjects);"
      echo "            sort64_${threshold}_object_$size(sorted, nobjects);"
      echo "            INSTR_TIME_SET_CURRENT(end_time);"
      echo "            INSTR_TIME_SUBTRACT(end_time, start_time);"
      echo "            elog(NOTICE, \"size=$size, order=$order, threshold=$threshold, cmp=64, test=%d, time=%f\", i, INSTR_TIME_GET_DOUBLE(end_time));"
      echo "        }"
    done
  done

  echo "        free(sorted);"
  echo "        free(unsorted);"
  echo "    }"
done
echo "}"
